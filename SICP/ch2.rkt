#lang racket

(require "common.rkt")
(require racket/trace)
(require sicp-pict)

(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))
(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))
(define (equal-rat? x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))
(define (make-rat n d)
  (cons n d))
(define (numer x) (car x))
(define (denom x) (cdr x))

(define (ex2.1)
  (define (make-rat n d)
    (let ((g (gcd n d))
          (p (* n d)))
      (let ((q (/ p (square g)))
            (m (abs (/ d g))))
        (cons (/ q m) m))))
  (println (make-rat 1 -2))
  (println (make-rat 2 -2))
  (println (make-rat 2 -4))
  (println (make-rat -2 -4))
  (println (make-rat 0 -4))
  )
(link 'ex2.1 ex2.1)

(define (ex2.2&ex2.3)
  (define (make-segment p1 p2)
    (cons p1 p2))
  (define (start-segment s)
    (car s))
  (define (end-segment s)
    (cdr s))
  (define (make-point x y)
    (cons x y))
  (define (x-point p)
    (car p))
  (define (y-point p)
    (cdr p))
  (define (midpoint-segment s)
    (let ((p1 (start-segment s))
          (p2 (end-segment s)))
      (make-point (/ (+ (x-point p1) (x-point p2)) 2)
                  (/ (+ (y-point p1) (y-point p2)) 2))))
  (define (print-point p)
    (newline)
    (display "(")
    (display (x-point p))
    (display ",")
    (display (y-point p))
    (display ")"))
  (define (print-segment s)
    (display "[")
    (print-point (start-segment s))
    (display ",")
    (print-point (end-segment s))
    (display "]"))
  (define s (make-segment (make-point 1 2)
                          (make-point 3 4)))
  (print-segment s)
  (print-point (midpoint-segment s))

  (define (make-rectangle width height)
    (cons width height))
  (define (rectangle-weight r)
    (car r))
  (define (rectangle-height r)
    (cdr r))
  (define (rectangle-area r)
    (* (rectangle-weight r)
       (rectangle-height r)))
  (define (rectangle-circumference r)
    (* 2 (+ (rectangle-weight r)
            (rectangle-height r))))
  (newline)
  (define r1 (make-rectangle 10 20))
  (println "rectangle area and circumference")
  (println (rectangle-area r1))
  (println (rectangle-circumference r1))
  )
(link 'ex2.2&ex2.3 ex2.2&ex2.3)

(define (ex2.4)
  (define (cons x y)
    (lambda (m) (m x y)))
  (define (car z)
    (z (lambda (p q) p)))
  (define (cdr z)
    (z (lambda (p q) q)))
  (println (cdr (cdr (cons 1 (cons 2 3)))))
  (println (cons 1 '()))
  )
(link 'ex2.4 ex2.4)

(define (ex2.5)
  (define (cons a b)
    (* (expt 2 a)
       (expt 3 b)))
  (define (car x)
    (if (= 0 (remainder x 2))
        (inc (car (/ x 2)))
        0))
  (define (cdr x)
    (if (= 0 (remainder x 3))
        (inc (car (/ x 3)))
        0))
  (define r (cons 2 3))
  (println r)
  (println (car r))
  (println (cdr r))
  )
(link 'ex2.5 ex2.5)

(define (ex2.6)
  (define zero (lambda (f) (lambda (x) x)))
  (define one (lambda (f) (lambda (x) (f x))))
  (define two (lambda (f) (lambda (x) (f (f x)))))
  
  (println ((zero square) 10))
  (println ((one square) 10))
  (println ((two square) 10))
  (define (+ a b)
    (lambda (f)
      (lambda (x)
        ((a f) ((b f) x)))))
  (define (* a b)
    (lambda (f)
      (lambda (x)
        ((a (b f)) x))))
  (define three (+ one two))
  (println (((+ one one) square) 10))
  (println (((* one one) inc) 1))
  (println (((+ two (+ one two)) inc) 1))
  (println (((* two (+ one two)) inc) 1))
  (println (((* three three) inc) 1))
  (println (((+ three three) inc) 1))
  (define (add-1 n)
    (lambda (f) (lambda (x) (f ((n f) x)))))
  (println zero)
  )
(link 'ex2.6 ex2.6)

((lambda ()
   (define (add-interval x y)
     (make-interval (+ (lower-bound x) (lower-bound y))
                    (+ (upper-bound x) (upper-bound y))))
   (define (mul-interval x y)
     (let ((p1 (* (lower-bound x) (lower-bound y)))
           (p2 (* (lower-bound x) (upper-bound y)))
           (p3 (* (upper-bound x) (lower-bound y)))
           (p4 (* (upper-bound x) (upper-bound y))))
       (make-interval (min p1 p2 p3 p4)
                      (max p1 p2 p3 p4))))
   (define (div-interval x y)
     (mul-interval x
                   (make-interval (/ 1.0 (upper-bound y))
                                  (/ 1.0 (lower-bound y)))))

   ;;; ex2.7
   (define (make-interval a b) (cons a b))
   (define (lower-bound p) (car p))
   (define (upper-bound p) (cdr p))
   
   (define (ex2.7)
     (define p1 (make-interval 1 2))
     (define p2 (make-interval 3 4))
     (println (add-interval p1 p2)))
   (link 'ex2.7 ex2.7)

   (define (sub-interval x y)
     (make-interval (- (lower-bound x) (upper-bound y))
                    (- (upper-bound x) (lower-bound y))))

   ;;; ex2.8
   (define (ex2.8)
     (define p1 (make-interval 1 2))
     (define p2 (make-interval 3 4))
     (println (sub-interval p1 p2))
     )
   (link 'ex2.8 ex2.8)
   
   ;;; ex2.9
   (define (ex2.9)
     ;;; 用中间值与区间宽度表示的区间
     (define (make-interval-v2 a b)
       (cons a b))
     (define (lower-bound p) (- (car p) (cdr p)))
     (define (upper-bound p) (+ (car p) (cdr p)))
     
     (define p1 (make-interval-v2 1 2))
     (define p2 (make-interval-v2 3 4))
     (println (sub-interval p1 p2))
     )
   (link 'ex2.9 ex2.9)

   (define (ex2.10)
     (define (div-interval x y)
       (let ((uy (upper-bound y))
             (ly (lower-bound y)))
         (if (and (< ly 0)
                  (> uy 0))
             (error "Invalid arguments -- div-interval")
             (mul-interval x
                           (make-interval (/ 1.0 uy)
                                          (/ 1.0 ly))))))
     (println (div-interval (make-interval 1 2)
                            (make-interval 2 3)))
     (println (div-interval (make-interval 1 2)
                            (make-interval -2 3)))
     )
   (link 'ex2.10 ex2.10)

   (define (ex2.11)
     ;;; 根据区间端点正负关系分成9种情况讨论
     (define (mul-interval x y)
       (let ((lx (lower-bound x))
             (ux (upper-bound x))
             (ly (lower-bound y))
             (uy (upper-bound y)))
         (cond ((< 0 lx)
                (cond ((< 0 ly) (make-interval (* lx ly) (* ux uy)))
                      ((< uy 0) (make-interval (* ux ly) (* lx uy)))
                      (else (make-interval (* ux ly) (* ux uy)))))
               ((< ux 0)
                (cond ((< 0 ly) (make-interval (* lx uy) (* ux ly)))
                      ((< uy 0) (make-interval (* ux uy) (* lx ly)))
                      (else (make-interval (* lx uy) (* lx ly)))))
               (else
                (cond ((< 0 ly) (make-interval (* lx uy) (ux uy)))
                      ((< uy 0) (make-interval (* ux ly) (* lx ly)))
                      (else (make-interval (min (* lx uy) (* ux ly))
                                           (max (* lx ly) (* ux uy)))))))))
     (define x (make-interval -100 -1))
     (define y (make-interval -100 -1))
     (println (mul-interval y x))
     (println (mul-interval x y))
     )
   (link 'ex2.11 ex2.11)

   (define (ex2.12&2.13)
     (define (make-center-width c w)
       (make-interval (- c w) (+ c w)))
     (define (center i)
       (/ (+ (lower-bound i) (upper-bound i)) 2))
     (define (width i)
       (/ (- (upper-bound i) (lower-bound i)) 2))
     
     (define (make-center-percent c p)
       (make-center-width c (* c (/ p 100.0))))
     (define (percent i)
       (* 100.0 (/ (- (upper-bound i) (lower-bound i))
                   (+ (upper-bound i) (lower-bound i)))))

     (define i1 (make-center-percent 100 1))
     (println i1)

     ;;; ex2.13 当误差很小时，两个区间乘积的误差约等于两个区间的误差之和
     (define i2 (make-center-percent 100 10))
     (println i2)

     (define i3 (make-center-percent 100 10))
     (println i3)
     
     (println (percent i2))
     (println (percent i3))
     (define i4 (mul-interval i2 i3))
     (println i4)
     (println (percent i4))
     )
   (link 'ex2.12&2.13 ex2.12&2.13)

   ;;; 这道题让我对初中的电阻计算公式认识更深了
   ;;; 误差范围较小时，两个公式计算结果接近
   (define (ex2.14)
     (define (par1 r1 r2)
       (div-interval (mul-interval r1 r2)
                     (add-interval r1 r2)))
     (define (par2 r1 r2)
       (let ((one (make-interval 1 1)))
         (div-interval one
                       (add-interval (div-interval one r1)
                                     (div-interval one r2)))))

     (define r1 (make-interval 10 20))
     (define r2 (make-interval 5 10))
     (println (par1 r1 r2))
     (println (par2 r1 r2))
     )
   (link 'ex2.14 ex2.14)

   (define (ex2.17)
     (define (last-pair list)
       (if (null? (cdr list))
           (cons (car list) '())
           (last-pair (cdr list))))
     (println (last-pair (list 23 72 149 34)))
     (println (last-pair '()))
     )
   (link 'ex2.17 ex2.17)
   
   (define (ex2.18)
     (define (reverse list)
       (if (null? list) '()
           (append (reverse (cdr list))
                   (cons (car list) '()))))
     (println (reverse '(1 2 3 4 5)))
     )
   (link 'ex2.18 ex2.18)

   (define (ex2.19)
     (define (count-change amount) (cc amount 5))
     (define (cc amount kinds-of-coins)
       (cond ((= amount 0) 1)
             ((or (< amount 0) (= kinds-of-coins 0)) 0)
             (else (+ (cc amount
                          (- kinds-of-coins 1))
                      (cc (- amount
                             (first-denomination
                              kinds-of-coins))
                          kinds-of-coins)))))
     (define (first-denomination kinds-of-coins)
       (cond ((= kinds-of-coins 1) 1)
             ((= kinds-of-coins 2) 5)
             ((= kinds-of-coins 3) 10)
             ((= kinds-of-coins 4) 25)
             ((= kinds-of-coins 5) 50))
       )
     (println (count-change 100))
     
     (define us-coins (list 50 25 10 5 1))
     (define uk-coins (list 100 50 20 10 5 2 1 0.5))

     (define (cc-v2 amount coin-values)
       (cond ((= amount 0) 1)
             ((or (< amount 0) (no-more? coin-values)) 0)
             (else
              (+ (cc-v2 amount
                        (except-first-denomination coin-values))
                 (cc-v2 (- amount
                           (first-denomination-v2 coin-values))
                        coin-values)))))
     (define no-more? null?)
     (define (first-denomination-v2 coin-values)
       (car coin-values))
     (define (except-first-denomination coin-values)
       (cdr coin-values))
     
     (println (cc-v2 100 us-coins))
     (println (cc-v2 10 uk-coins))
     )
   (link 'ex2.19 ex2.19)
   
   (define (ex2.20)
     ((λ ()
        (define (same-parity u . lst)
          (cond [(null? lst) (list u)]
                [(eq? (odd? u) (odd? (car lst)))
                 (cons u (apply same-parity lst))]
                [else
                 (apply same-parity u (cdr lst))]))
        (println (same-parity 1))
        (println (same-parity 1 1 1 1 1 1))
        (println (same-parity 1 2 3 4 5))
        (println (same-parity 2 3 4 5 6))
        ))

     ((λ ()
        (define (same-parity u . list)
          (cons u (filter (if (odd? u) odd? even?) list)))
        (println (same-parity 1))
        (println (same-parity 1 1 1 1 1 1))
        (println (same-parity 1 2 3 4 5))
        (println (same-parity 2 3 4 5 6))
        ))
     )
   (link 'ex2.20 ex2.20)

   (define (ex2.21)
     ((λ ()
        (define (square-list items)
          (if (null? items) '()
              (cons (square (car items))
                    (square-list (cdr items)))))
        (println (square-list '(1 2 3 4)))
        ))
     ((λ ()
        (define (square-list items)
          (map square items))
        (println (square-list '(1 2 3 4)))
        ))
     )
   (link 'ex2.21 ex2.21)

   (define (ex2.22)
     ;;; 错误的迭代版本1
     ((λ ()
        (define (square-list items)
          (define (iter things answer)
            (if (null? things) answer
                (iter (cdr things)
                      (cons (square (car things))
                            answer))))
          (iter items '()))
        (println (square-list '(1 2 3 4)))))
     ;;; 错误的迭代版本2
     ((λ ()
        (define (square-list items)
          (define (iter things answer)
            (if (null? things) answer
                (iter (cdr things)
                      (cons answer (square (car things))))))
          (iter items '()))
        (println (square-list '(1 2 3 4)))
        ))
     ;;; 正确实现迭代版本
     ((λ ()
        (define (square-list items)
          (define (iter things answer)
            (if (null? things) answer
                (iter (cdr things)
                      (append answer (list (square (car things)))))))
          (iter items '()))
        (println (square-list '(1 2 3 4)))
        ))
     )
   (link 'ex2.22 ex2.22)

   (define (ex2.23)
     (define (for-each f items)
       (if (null? items) (void)
           (begin
             (f (car items))
             (for-each f (cdr items)))))
     (for-each display '(1 2 3 4 5))
     )
   (link 'ex2.23 ex2.23)

   (define (count-leaves x)
     (cond ((null? x) 0)
           ((not (pair? x)) 1)
           (else
            (+ (count-leaves (car x))
               (count-leaves (cdr x))))))
   (define x (cons (list 1 2) (list 3 4)))
   (println (count-leaves (list x x)))
   (println (count-leaves (cons (list 1 2) (list 3 4))))

   (define (ex2.25)
     (println (car (cdr (car (cdr (cdr '(1 2 (5 7) 9)))))))
     (println (car (car '((7)))))
     (println (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr '(1 (2 (3 (4 (5 (6 7)))))))))))))))))))
     )
   (link 'ex2.25 ex2.25)

   (define (ex2.26)
     (define x (list 1 2 3))
     (define y (list 4 5 6))
     (println (append x y))
     (println (cons x y))
     (println (list x y)))
   (link 'ex2.26 ex2.26)

   (define (ex2.27)
     (define (deep-reverse lst)
       (cond ((null? lst) '())
             ((not (pair? lst)) lst)
             (else (append (deep-reverse (cdr lst))
                           (list (deep-reverse (car lst)))))))
     (println (deep-reverse '(1 2 3 4)))
     (println (deep-reverse '((1 2) (3 4))))
     (println (deep-reverse '((1 2) (3 4) 5 6)))
     )
   (link 'ex2.27 ex2.27)

   (define (ex2.28)
     ((λ ()
        (define (fringe lst)
          (cond ((null? lst) '())
                ((not (pair? lst)) (list lst))
                (else
                 (append (fringe (car lst))
                         (fringe (cdr lst))))))
        (println (fringe '((1 2) (3 4))))
        ))
     )
   (link 'ex2.28 ex2.28)
   (define (ex2.29)
     ((λ ()
        (define (make-mobile left right)
          (list left right))
        (define (make-branch length structure)
          (list length structure))
        (define (left-branch mobile)
          (car mobile))
        (define (right-branch mobile)
          (car (cdr mobile)))
        (define (branch-length branch)
          (car branch))
        (define (branch-weight branch)
          (car (cdr branch)))
        (define (total-weight mobile)
          (if (number? mobile) mobile
              (+ (total-weight (branch-weight (left-branch mobile)))
                 (total-weight (branch-weight (right-branch mobile))))))
        (define m (make-mobile (make-branch 1 (make-mobile (make-branch 10 10)
                                                           (make-branch 10 10)))
                               (make-branch 2 (make-mobile (make-branch 3 7)
                                                           (make-branch 7 3)))))
        (println (total-weight m))
        (define (balanced? mobile)
          (if (not (pair? mobile)) #t
              (and
               (= (* (branch-length (left-branch mobile))
                     (total-weight (branch-weight (left-branch mobile))))
                  (* (branch-length (right-branch mobile))
                     (total-weight (branch-weight (right-branch mobile)))))
               (balanced? (branch-weight (left-branch mobile)))
               (balanced? (branch-weight (right-branch mobile))))))
        (println (balanced? m))
        ))
     ((λ ()
        (define (make-mobile left right)
          (cons left right))
        (define (make-branch length structure)
          (cons length structure))
        (define (left-branch mobile)
          (car mobile))
        (define (right-branch mobile)
          (cdr mobile))
        (define (branch-length branch)
          (car branch))
        (define (branch-weight branch)
          (cdr branch))
        (define (total-weight mobile)
          (if (number? mobile) mobile
              (+ (total-weight (branch-weight (left-branch mobile)))
                 (total-weight (branch-weight (right-branch mobile))))))
        (define m (make-mobile (make-branch 1 (make-mobile (make-branch 10 10)
                                                           (make-branch 10 10)))
                               (make-branch 2 (make-mobile (make-branch 3 7)
                                                           (make-branch 7 3)))))
        (println (total-weight m))
        (define (balanced? mobile)
          (if (not (pair? mobile)) #t
              (and
               (= (* (branch-length (left-branch mobile))
                     (total-weight (branch-weight (left-branch mobile))))
                  (* (branch-length (right-branch mobile))
                     (total-weight (branch-weight (right-branch mobile)))))
               (balanced? (branch-weight (left-branch mobile)))
               (balanced? (branch-weight (right-branch mobile))))))
        (println (balanced? m))
        ))
     )
   (link 'ex2.29 ex2.29)

   (define (ex2.30)
     (define lst '(1 (2 (3 4) 5)))
     ((λ ()
        (define (square-tree lst)
          (cond ((null? lst) '())
                ((not (pair? lst)) (square lst))
                (else (cons (square-tree (car lst))
                            (square-tree (cdr lst))))))
        (println (square-tree lst))
        ))
     ((λ ()
        (define (square-tree lst)
          (map (λ (l)
                 (if (pair? l)
                     (square-tree l)
                     (square l)))
               lst))
        (println (square-tree lst))
        (println (square-tree '(1 (2 3 (4 5 6)))))
        ))
     )
   (link 'ex2.30 ex2.30)

   (define (ex2.31)
     ((λ ()
        (define (tree-map f tree)
          (map (λ (l)
                 (if (pair? l)
                     (tree-map f l)
                     (f l)))
               tree))
        (define lst '(1 (2 3 (4 5 6))))
        (println (tree-map square lst))
        (println (tree-map (λ (x) (+ x x x)) lst))
        ))
     )
   (link 'ex2.31 ex2.31)

   (define (ex2.32)
     (define (subsets s)
       (if (null? s)
           (list '())
           (let ((rest (subsets (cdr s))))
             (append rest (map (λ (x)
                                 (cons (car s) x)) rest)))))
     (println (subsets '(1 2 3)))
     (println (subsets '(1 2 3 4)))
     )
   (link 'ex2.32 ex2.32)

   (define (accumulate op initial sequence)
     (if (null? sequence)
         initial
         (op (car sequence)
             (accumulate op initial (cdr sequence)))))
   (define (ex2.33)
     (define (map p sequence)
       (accumulate (lambda (x y)
                     (if (null? y)
                         (list (p x))
                         (cons (p x) y))) '() sequence))
     (println (map inc '(1 2 3 4)))
     (println (map square '(1 2 3 4 5)))
     
     (define (append seq1 seq2)
       (accumulate cons seq2 seq1))
     (println (append '(1 2 3) '(4 5 6)))

     (define (length sequence)
       (accumulate (lambda (x y)
                     (+ y 1))
                   0
                   sequence))
     (println (length '(1 2 3 4 5)))
     (println (length '()))

     (define (sum sequence)
       (accumulate (lambda (x y)
                     (+ x y))
                   0
                   sequence))
     (println (sum '(1 2 3 4 5 6)))
     )
   (link 'ex2.33 ex2.33)

   (define (ex2.34)
     (define (horner-eval x coefficient-sequence)
       (accumulate (lambda (this-coeff higher-terms)
                     (+ this-coeff
                        (* x higher-terms)))
                   0
                   coefficient-sequence))
     (println (horner-eval 2 '(1 3 0 5 0 1)))
     (println (horner-eval 3 '(1 2 1)))
     )
   (link 'ex2.34 ex2.34)

   (define (ex2.35)
     ((λ ()
        (define (count-leaves t)
          (accumulate (lambda (x y)
                        (+ y
                           (if (list? x)
                               (count-leaves x)
                               1)))
                      0
                      t))
        (println (count-leaves '(1)))
        (println (count-leaves '(1 (2 3))))
        (println (count-leaves '(())))
        ))
     ((λ ()
        (define (count-leaves t)
          (accumulate (lambda (x y)
                        (+ x y))
                      0
                      (map (lambda (x)
                             (if (list? x)
                                 (count-leaves x)
                                 1))
                           t)))
        (println (count-leaves '(1)))
        (println (count-leaves '(1 (2 3))))
        (println (count-leaves '(())))
        ))
     )
   (link 'ex2.35 ex2.35)

   (define (accumulate-n op init seqs)
     (if (null? (car seqs))
         '()
         (cons (accumulate op init (map car seqs))
               (accumulate-n op init (map cdr seqs)))))
   (define (ex2.36)
     (println (accumulate-n + 0 '((1 2 3) (4 5 6) (7 8 9) (10 11 12))))
     )
   (link 'ex2.36 ex2.36)

   (define (ex2.37)
     (define m '((1 2 3 4) (4 5 6 6) (6 7 8 9)))
     (define (dot-product v w)
       (accumulate + 0 (map * v w)))
     (define (matrix-*-vector m v)
       (map (lambda (x)
              (dot-product x v)) m))
     (define (transpose m)
       (accumulate-n cons '() m))
     (println (matrix-*-vector m '(1 2 3 4)))
     (println (transpose m))
     (println (transpose '((1 4 6) (2 5 7) (3 6 8) (4 6 9))))
     (define (matrix-*-matrix m n)
       (let ((cols (transpose n)))
         (map (lambda (v)
                (matrix-*-vector cols v)) m)))
     (println (matrix-*-matrix m (transpose m)))
     )
   (link 'ex2.37 ex2.37)

   (define fold-right accumulate)
   (define (fold-left op initial sequence)
     (define (iter result rest)
       (if (null? rest)
           result
           (iter (op result (car rest))
                 (cdr rest))))
     (iter initial sequence))
   
   (define (ex2.38)
     (println (fold-right / 1 (list 1 2 3)))
     (println (fold-left / 1 (list 1 2 3)))

     (println (fold-right list '() (list 1 2 3)))
     (println (fold-left list '() (list 1 2 3)))

     (println (fold-right + 1 (list 1 2 3)))
     (println (fold-left + 1 (list 1 2 3)))

     ;;; 要使fold-left与fold-right结果相同
     ;;; 必须满足 (op a b)与(op b a)结果一样
     )
   (link 'ex2.38 ex2.38)

   (define (ex2.39)
     ((λ ()
        (define (reverse sequence)
          (fold-right (lambda (x y) (cons x y)) '() sequence))
        (println (reverse '(1 2 3 4 5)))
        ))
     ((λ ()
        (define (reverse sequence)
          (fold-left (lambda (x y) (append x (list y))) '() sequence))
        (println (reverse '(1 2 3 4 5)))
        ))
     )
   (link 'ex2.39 ex2.39)


   (define (enumerate-interval m n)
     (if (> m n) '()
         (cons m
               (enumerate-interval (+ m 1) n))))
   
   (define (enum-list n)
     (accumulate append
                 '()
                 (map (lambda (i)
                        (map (lambda (j) (list i j))
                             (enumerate-interval 1 (- i 1))))
                      (enumerate-interval 1 n))))
   
   (define (flatmap proc seq)
     (accumulate append '() (map proc seq)))
   (define (prime-sum? pair)
     (prime? (+ (car pair) (cadr pair))))

   (define (make-pair-sum pair)
     (list (car pair) (cadr pair) (+ (car pair) (cadr pair))))

   (define (prime-sum-pairs n)
     (map make-pair-sum
          (filter prime-sum?
                  (flatmap
                   (lambda (i)
                     (map (lambda (j) (list i j))
                          (enumerate-interval 1 (- i 1))))
                   (enumerate-interval 1 n)))))
   (define (permutations s)
     (if (null? s)
         (list '())
         (flatmap (lambda (x)
                    (map (lambda (p) (cons x p))
                         (permutations (remove x s))))
                  s)))
   (define (remove item sequence)
     (filter (lambda (x) (not (= x item)))
             sequence))

   (define (NestedMappings)
     (println (enumerate-interval 1 4))
     (println (enum-list 5))
     (println (prime-sum-pairs 5))
     )
   (link 'NestedMappings NestedMappings)

   (define (ex2.40)
     (define (unique-pairs n)
       (accumulate append
                   '()
                   (map (lambda (i)
                          (map (lambda (j) (list i j))
                               (enumerate-interval 1 (- i 1))))
                        (enumerate-interval 1 n))))
     (define (prime-sum-pairs n)
       (filter prime-sum?
               (unique-pairs n)))
     (println (prime-sum-pairs 10))
     )
   (link 'ex2.40 ex2.40)

   (define (ex2.41)
     ((λ ()
        (define (unique-pairs-3 n)
          (accumulate append
                      '()
                      (map (lambda (i)
                             (accumulate append
                                         '()
                                         (map (lambda (j)
                                                (map (lambda (k)
                                                       (list i j k))
                                                     (enumerate-interval (+ j 1) n)))
                                              (enumerate-interval (+ i 1) n))))
                           (enumerate-interval 1 n))))
        (define (f n s)
          (filter (lambda (lst)
                    (= s (apply + lst)))
                  (unique-pairs-3 n)))
        (println (f 10 20))
        ))
     )
   (link 'ex2.41 ex2.41)

   (define (ex2.42)
     (define empty-board '())
     (define (can-attack? row col elem)
       (let ((r (car elem))
             (c (cdr elem)))
         (or (= col c)
             (= (+ row col) (+ r c))
             (= (- row col) (- r c)))))
     (define (in-positions? row col positions)
       (if (null? positions)
           #f
           (or (can-attack? row col (car positions))
               (in-positions? row col (cdr positions)))))
     (define (safe? k positions)
       (if (null? positions) #t
           (not (in-positions? k (cdr (car positions)) (cdr positions)))))
     (define (adjoin-position new-row k rest-of-queens)
       (cons (cons k new-row)
             rest-of-queens))
     (define (queens board-size)
       (define (queen-cols k)
         (if (= k 0)
             (list empty-board)
             (filter
              (lambda (positions) (safe? k positions))
              (flatmap
               (lambda (rest-of-queens)
                 (map (lambda (new-row)
                        (adjoin-position new-row k rest-of-queens))
                      (enumerate-interval 1 board-size)))
               (queen-cols (- k 1))))))
       (queen-cols board-size))
     (println (queens 8))
     )
   (link 'ex2.42 ex2.42)

   (define (ex2.43)
     (define empty-board '())
     (define (can-attack? row col elem)
       (let ((r (car elem))
             (c (cdr elem)))
         (or (= col c)
             (= (+ row col) (+ r c))
             (= (- row col) (- r c)))))
     (define (in-positions? row col positions)
       (if (null? positions)
           #f
           (or (can-attack? row col (car positions))
               (in-positions? row col (cdr positions)))))
     (define (safe? k positions)
       (if (null? positions) #t
           (not (in-positions? k (cdr (car positions)) (cdr positions)))))
     (define (adjoin-position new-row k rest-of-queens)
       (cons (cons k new-row)
             rest-of-queens))
     (define (queens board-size)
       (define (queen-cols k)
         (if (= k 0)
             (list empty-board)
             (filter
              (lambda (positions) (safe? k positions))
              (flatmap
               (lambda (new-row)
                 (map (lambda (rest-of-queens)
                        (adjoin-position new-row k rest-of-queens))
                      (queen-cols (- k 1))))
               (enumerate-interval 1 board-size)))))
       (queen-cols board-size))
     (println (queens 8))
     )
   (link 'ex2.43 ex2.43)
   (define (ex2.44)
     (define (right-split painter n)
       (if (= n 0)
           painter
           (let ((smaller (right-split painter (- n 1))))
             (beside painter (below smaller smaller)))))
     (define (up-split painter n)
       (if (= n 0)
           painter
           (let ((smaller (up-split painter (- n 1))))
             (below painter (beside smaller smaller)))))
     (define (corner-split painter n)
       (if (= n 0)
           painter
           (let ((up (up-split painter (- n 1)))
                 (right (right-split painter (- n 1))))
             (let ((top-left (beside up up))
                   (bottom-right (below right right))
                   (corner (corner-split painter (- n 1))))
               (beside (below painter top-left)
                       (below bottom-right corner))))))
     ;     (define (square-limit painter n)
     ;       (let ((quarter (corner-split painter n)))
     ;         (let ((half (beside (flip-horis quarter) quarter)))
     ;           (below (flip-vert half) half))))
     (paint (corner-split einstein 4))
     )
   (link 'ex2.44 ex2.44)
   (define (ex2.45)
     (define (split f1 f2)
       (lambda (painter n)
         (if (= n 0)
             painter
             (let ((smaller ((split f1 f2) painter (- n 1))))
               (f1 painter (f2 smaller smaller))))))
     (define right-split (split beside below))
     (define up-split (split below beside))
     (define (corner-split painter n)
       (if (= n 0)
           painter
           (let ((up (up-split painter (- n 1)))
                 (right (right-split painter (- n 1))))
             (let ((top-left (beside up up))
                   (bottom-right (below right right))
                   (corner (corner-split painter (- n 1))))
               (beside (below painter top-left)
                       (below bottom-right corner))))))
     (paint (corner-split einstein 4))
     )
   (link 'ex2.45 ex2.45)
   (define (frame-coord-map frame)
     (lambda (v)
       (add-vect
        (origin-frame frame)
        (add-vect
         (scale-vect (xcor-vect v)
                     (edge1-frame frame))
         (scale-vect (ycor-vect v)
                     (edge2-frame frame))))))
   (define (make-vect x y)
     (cons x y))
   (define (xcor-vect v)
     (car v))
   (define (ycor-vect v)
     (cdr v))
   (define (vect-op op v1 v2)
     (make-vect (op (xcor-vect v1)
                    (xcor-vect v2))
                (op (ycor-vect v1)
                    (ycor-vect v2))))
   (define (add-vect v1 v2)
     (vect-op + v1 v2))
   (define (sub-vect v1 v2)
     (vect-op - v1 v2))
   (define (scale-vect s v)
     (make-vect (* s
                   (xcor-vect v))
                (* s
                   (ycor-vect v))))
   (define (ex2.46)
     (define v1 (make-vect 1 2))
     (define v2 (make-vect 2 4))
     (define s 3)
     (println (add-vect v1 v2))
     (println (sub-vect v2 v1))
     (println (scale-vect s v1))
     )
   (link 'ex2.46 ex2.46)
   (define (make-frame origin edge1 edge2)
     (list origin edge1 edge2))
   (define (origin-frame frame)
     (car frame))
   (define (edge1-frame frame)
     (cadr frame))
   (define (edge2-frame frame)
     (caddr frame))
   (println ((frame-coord-map (make-frame (make-vect 1 1)
                                          (make-vect 1 0.5)
                                          (make-vect 0 1))) (make-vect 3 3)))
   (define (ex2.47)
     ;;; 需要实现 origin-grame, edge1-frame edge2-frame
     ;;; 三个方法
     ((λ ()
        (define (make-frame origin edge1 edge2)
          (list origin edge1 edge2))
        (define (origin-frame frame)
          (car frame))
        (define (edge1-frame frame)
          (cadr frame))
        (define (edge2-frame frame)
          (caddr frame))
        (define f (make-frame 'origin-frame 'edge1-frame 'edge2-frame))
        (println (origin-frame f))
        (println (edge1-frame f))
        (println (edge2-frame f))
        ))
     ((λ ()
        (define (make-frame origin edge1 edge2)
          (cons origin (cons edge1 edge2)))
        (define (origin-frame frame)
          (car frame))
        (define (edge1-frame frame)
          (cadr frame))
        (define (edge2-frame frame)
          (cddr frame))
        (define f (make-frame 'origin-frame 'edge1-frame 'edge2-frame))
        (println (origin-frame f))
        (println (edge1-frame f))
        (println (edge2-frame f))
        ))
     )
   (link 'ex2.47 ex2.47)
   (define (draw-line v1 v2)
     (vects->painter (list (make-vect (car v1) (cdr v1))
                           (make-vect (car v2) (cdr v2)))))
   (define (segments->painter segment-list)
     (lambda (frame)
       (for-each
        (lambda (segment)
          (draw-line
           ((frame-coord-map frame) (segment-start segment))
           ((frame-coord-map frame) (segment-end segment))))
        segment-list)))
   (define (ex2.48)
     (define (make-vect x y)
       (cons x y))
     (define (xcor-vect v)
       (car v))
     (define (ycor-vect v)
       (cdr v))
     (define (make-segment v1 v2)
       (cons v1 v2))
     (define (start-segment s)
       (car s))
     (define (end-segment s)
       (cdr s))
     '()
     )
   (link 'ex2.48 ex2.48)
   (define (transform-painter painter origin corner1 corner2)
     (lambda (frame)
       (let ((m (frame-coord-map frame)))
         (let ((new-origin (m origin)))
           (painter
            (make-frame new-origin
                        (sub-vect (m corner1) new-origin)
                        (sub-vect (m corner2) new-origin)))))))
   (define (flip-vect painter)
     (transform-painter painter
                        (make-vect 0.0 1.0)
                        (make-vect 1.0 1.0)
                        (make-vect 0.0 0.0)))
   (define (shrink-to-upper-right painter)
     (transform-painter
      painter
      (make-vect 0.5 0.5)
      (make-vect 1.0 0.5)
      (make-vect 0.5 1.0)))
   (define (rotate90 painter)
     (transform-painter painter
                        (make-vect 1.0 0.0)
                        (make-vect 1.0 1.0)
                        (make-vect 0.0 0.0)))
   (define (squash-inwards painter)
     (transform-painter painter
                        (make-vect 0.0 0.0)
                        (make-vect 0.65 0.35)
                        (make-vect 0.35 0.65)))
   (define (beside painter1 painter2)
     (let ((split-point (make-vect 0.5 0.0)))
       (let ((paint-left
              (transform-painter painter1
                                 (make-vect 0.0 0.0)
                                 split-point
                                 (make-vect 0.0 1.0)))
             (paint-right
              (transform-painter painter2
                                 split-point
                                 (make-vect 1.0 0.0)
                                 (make-vect 0.5 1.0))))
         (lambda (frame)
           (paint-left frame)
           (paint-right frame)))))
   (define (ex2.50)
     (define (flip-horiz painter)
       (transform-painter painter
                          '()))
     '())
   (define (ex2.53)
     (println (list 'a 'b 'c))
     (println (list (list 'george)))
     (println (cdr '((x1 x2) (y1 y2))))
     (println (cadr '((x1 x2) (y1 y2))))
     (println (pair? (car '(a short list))))
     (define (memq item x)
       (cond ((null? x) false)
             ((eq? item (car x)) x)
             (else (memq item (cdr x)))))
     (println (memq 'red '((red shoes) (blue socks))))
     (println (memq 'red '(red shoes blue socks)))
     )
   (link 'ex2.53 ex2.53)
   
   (define (ex2.54)
     (define (equal? l1 l2)
       (cond ((empty? l1) (empty? l2))
             ((empty? l2) (empty? l1))
             (else
              (let ((e1 (car l1))
                    (e2 (car l2)))
                (cond ((eq? e1 e2)
                       (equal? (cdr l1) (cdr l2)))
                      (else
                       (and (pair? e1)
                            (pair? e2)
                            (equal? e1 e2)
                            (equal? (cdr l1) (cdr l2)))))))))
     (println (equal? '(1 2 3) '(1 2 3)))
     (println (equal? '(1 2 3) '(1 2 4)))
     (println (equal? '((1) (2) (3)) '(1 2 4)))
     (println (equal? '((1) (2) (3)) '((1) (2) (3))))
     )
   (link 'ex2.54 ex2.54)

   (define (variable? x) (symbol? x))
   (define (same-variable? v1 v2)
     (and (variable? v1) (variable? v2) (eq? v1 v2)))
   ;   (define (make-sum a1 a2) (list '+ a1 a2))
   (define (make-sum a1 a2)
     (cond ((=number? a1 0) a2)
           ((=number? a2 0) a1)
           ((and (number? a1) (number? a2)) (+ a1 a2))
           (else
            (list '+ a1 a2))))
   (define (=number? exp num)
     (and (number? exp) (= exp num)))
   
   ;   (define (make-product m1 m2) (list '* m1 m2))
   (define (make-product m1 m2)
     (cond ((or (=number? m1 0) (=number? m2 0)) 0)
           ((=number? m1 1) m2)
           ((=number? m2 1) m1)
           ((and (number? m1) (number? m2)) (* m1 m2))
           (else
            (list '* m1 m2))))
   (define (sum? x)
     (and (pair? x) (eq? (car x) '+)))
   (define (addend s) (cadr s))
   (define (augend s) (caddr s))
   (define (product? x)
     (and (pair? x) (eq? (car x) '*)))
   (define (multiplier p) (cadr p))
   (define (multiplicand p) (caddr p))
   (define (deriv exp var)
     (cond ((number? exp) 0)
           ((variable? exp)
            (if (same-variable? exp var) 1 0))
           ((sum? exp)
            (make-sum (deriv (addend exp) var)
                      (deriv (augend exp) var)))
           ((product? exp)
            (make-sum
             (make-product (multiplier exp)
                           (deriv (multiplicand exp) var))
             (make-product (deriv (multiplier exp) var)
                           (multiplicand exp))))
           (else
            (error "unknown expression type -- DERIV" exp))))
   (define (deriv-examples)
     (println (deriv '(+ x 3) 'x))
     (println (deriv '(* x y) 'x))
     (println (deriv '(* (* x y) (+ x 3)) 'x))
     (println (deriv '(* a (* x x)) 'x))
     )
   (link 'deriv-examples deriv-examples)
   (define (ex2.56)
     (define (exponentiation? exp)
       (and (pair? exp) (eq? (car exp) '**)))
     (define (base exp)
       (cadr exp))
     (define (exponent exp)
       (caddr exp))
     (define (make-exponentiation e1 e2)
       (list '** e1 e2))
     (define (make-diff a1 a2)
       (list '- a1 a2))
     (define (deriv exp var)
       (cond ((number? exp) 0)
             ((variable? exp)
              (if (same-variable? exp var) 1 0))
             ((sum? exp)
              (make-sum (deriv (addend exp) var)
                        (deriv (augend exp) var)))
             ((product? exp)
              (make-sum
               (make-product (multiplier exp)
                             (deriv (multiplicand exp) var))
               (make-product (deriv (multiplier exp) var)
                             (multiplicand exp))))
             ((exponentiation? exp)
              (make-product (exponent exp)
                            (make-exponentiation (base exp)
                                                 (make-diff (exponent exp) 1))))
             (else
              (error "unknown expression type -- DERIV" exp))))
     (println (deriv '(** x n) 'x))
     )
   (link 'ex2.56 ex2.56)
   (define (ex2.57)
     ;;; 扩充求导程序，使之支持多个多个项的和与积
     (define (addend s) (cadr s))
     (define (augend s) 
       (if (null? (cdddr s))
           (caddr s)
           (cons '+ (cddr s))))
     (define (multiplier p) (cadr p))
     (define (multiplicand p)
       (if (null? (cdddr p))
           (caddr p)
           (cons '+ (cddr p))))
     (define (parse-elems operator exp)
       (if (and (pair? exp) (eq? operator (car exp)))
           (cdr exp)
           (list exp)))
     (define (make-sum a1 a2)
       (cond ((=number? a1 0) a2)
             ((=number? a2 0) a1)
             ((and (number? a1) (number? a2)) (+ a1 a2))
             (else
              (cons '+ (append (parse-elems '+ a1)
                               (parse-elems '+ a2))))))
               
     ;             ((and (pair? a1) (eq? '+ (car a1)))
     ;              (if (and (pair? a2) (eq? '+ (car a2)))
     ;                  (append a1 (cdr a2))
     ;                  (append a1 (list a2))))
     ;             ((and (pair? a2) (eq? '+ (car a2)))
     ;              (if (and (pair? a1) (eq? '+ (car a1)))
     ;                  (append a2 (cdr a1))
     ;                  (append a2 (list a1))))
     ;             (else
     ;              (list '+ a1 a2))))
     (define (deriv exp var)
       (cond ((number? exp) 0)
             ((variable? exp)
              (if (same-variable? exp var) 1 0))
             ((sum? exp)
              (make-sum (deriv (addend exp) var)
                        (deriv (augend exp) var)))
             ((product? exp)
              (make-sum
               (make-product (multiplier exp)
                             (deriv (multiplicand exp) var))
               (make-product (deriv (multiplier exp) var)
                             (multiplicand exp))))
             (else
              (error "unknown expression type -- DERIV" exp))))
     (println (deriv '(+ x (* 2 x) (* a x) (* b x) (* c x)) 'x))
     (println (deriv '(* x (* 2 x) (* a x) (* b x) (* c x)) 'x))
     )
   (link 'ex2.57 ex2.57)
   (define (ex2.58)
     ;;; a
     ;;; 扩充求导程序，使之支持多个多个项的和与积
     (define (addend s) (car s))
     (define (augend s)
       (if (null? (cdddr s))
           (caddr s)
           (cons '+ (cddr s))))
     (define (multiplier p) (car p))
     (define (multiplicand p)
       (if (null? (cdddr p))
           (caddr p)
           (cons '+ (cddr p))))
     (define (parse-elems operator exp)
       (if (and (pair? exp) (eq? operator (cadr exp)))
           (car exp)
           (list exp)))
     (define (make-sum a1 a2)
       (cond ((=number? a1 0) a2)
             ((=number? a2 0) a1)
             ((and (number? a1) (number? a2)) (+ a1 a2))
             (else
              (append (parse-elems '+ a1)
                      (list '+)
                      (parse-elems '+ a2)))))
     (define (make-product m1 m2)
       (cond ((or (=number? m1 0) (=number? m2 0)) 0)
             ((=number? m1 1) m2)
             ((=number? m2 1) m1)
             ((and (number? m1) (number? m2)) (* m1 m2))
             (else
              (list m1 '* m2))))
     (define (sum? x)
       (and (pair? x) (eq? (cadr x) '+)))
     (define (product? x)
       (and (pair? x) (eq? (cadr x) '*)))
     (define (deriv exp var)
       (cond ((number? exp) 0)
             ((variable? exp)
              (if (same-variable? exp var) 1 0))
             ((sum? exp)
              (make-sum (deriv (addend exp) var)
                        (deriv (augend exp) var)))
             ((product? exp)
              (make-sum
               (make-product (multiplier exp)
                             (deriv (multiplicand exp) var))
               (make-product (deriv (multiplier exp) var)
                             (multiplicand exp))))
             (else
              (error "unknown expression type -- DERIV" exp))))
     (println (deriv '(3 * (x * x)) 'x))
     ;     (println (deriv '(x + x + x) 'x))
     ;;; b
     ;;; 支持标准的代数写法
     )
   (link 'ex2.58 ex2.58)

   (define (element-of-set? x set)
     (cond ((null? set) false)
           ((equal? x (car set)) true)
           (else (element-of-set? x (cdr set)))))
   (define (adjoin-set x set)
     (if (element-of-set? x set)
         set
         (cons x set)))

   (define (intersection-set set1 set2)
     (cond ((or (null? set1) (null? set2)) '())
           ((element-of-set? (car set1) set2)
            (cons (car set1)
                  (intersection-set (cdr set1) set2)))
           (else (intersection-set (cdr set1) set2))))
   (define (ex2.59)
     (define (union-set set1 set2)
       (cond ((null? set2) set1)
             ((null? set1) set2)
             (else (if (element-of-set? (car set1) set2)
                       (union-set (cdr set1) set2)
                       (union-set (cdr set1) (cons (car set1) set2))))))            
     (println (union-set '(1 2 3) '(4 5 6)))
     (println (union-set '(1 2 3) '(1 2 4)))
     )
   (link 'ex2.59 ex2.59)

   (define (ex2.60)
     (define (element-of-set? x set)
       (cond ((null? set) false)
             ((equal? x (car set)) true)
             (else (element-of-set? x (cdr set)))))
     (define (adjoin-set x set)
       (cons x set))
     (define (intersection-set set1 set2)
       (cond ((or (null? set1) (null? set2)) '())
             ((element-of-set? (car set1) set2)
              (cons (car set1)
                    (intersection-set (cdr set1) set2)))
             (else (intersection-set (cdr set1) set2))))
     (define (union-set set1 set2)
       (cond ((null? set2) set1)
             ((null? set1) set2)
             (else (union-set (cdr set1) (cons (car set1) set2)))))
     (println (union-set '(1 2 3) '(4 5 6)))
     (println (union-set '(1 2 3) '(1 2 4)))
     )
   (link 'ex2.60 ex2.60)
   
   (define (sets-as-ordered-lists)
     (define (element-of-set? x set)
       (cond ((null? set) false)
             ((= x (car set)) true)
             ((< x (car set)) false)
             (else (element-of-set? x (cdr set)))))
     (define (intersection-set s1 s2)
       (if (or (null? s1) (null? s2))
           '()
           (let ((x1 (car s1))
                 (x2 (car s2)))
             (cond ((= x1 x2)
                    (cons x1 (intersection-set (cdr s1)
                                               (cdr s2))))
                   ((< x1 x2)
                    (intersection-set (cdr s1) s2))
                   ((< x2 x1)
                    (intersection-set s1 (cdr s2)))))))
     (println (element-of-set? 1 '(1 2 3)))
     (println (intersection-set '(1 2 3) '(2 3 4)))
     
     (define (ex2.61)
       (define (adjoin-set x set)
         (cond ((null? set) (cons x '()))
               ((< x (car set)) (cons x set))
               ((= x (car set)) set)
               (else (cons (car set) (adjoin-set x (cdr set))))))
       (println (adjoin-set 1 '(1 2)))
       (println (adjoin-set 2 '(1 3)))
       )
     (link 'ex2.61 ex2.61)
     (define (ex2.62)
       (define (union-set s1 s2)
         (cond ((null? s1) s2)
               ((null? s2) s1)
               (else
                (let ((x1 (car s1))
                      (x2 (car s2)))
                  (cond ((< x1 x2)
                         (cons x1 (union-set (cdr s1) s2)))
                        ((< x2 x1)
                         (cons x2 (union-set s1 (cdr s2))))
                        (else
                         (cons x1 (union-set (cdr s1) (cdr s2)))))))))
       (println (union-set '(1 2 3) '(2 3 4)))
       )
     (link 'ex2.62 ex2.62)
     )
   (link 'sets-as-ordered-lists sets-as-ordered-lists)
   (define (sets-as-binary-tree)
     (define (entry tree) (car tree))
     (define (left-branch tree) (cadr tree))
     (define (right-branch tree) (caddr tree))
     (define (make-tree entry left right)
       (list entry left right))
     (define (element-of-set? x set)
       (cond ((null? set) false)
             ((= x (entry set)) true)
             ((< x (entry set))
              (element-of-set? x (left-branch set)))
             ((> x (entry set))
              (element-of-set? x (right-branch set)))))
     (define (adjoin-set x set)
       (cond ((null? set) (make-tree x '() '()))
             ((= x (entry set)) set)
             ((< x (entry set))
              (make-tree (entry set)
                         (adjoin-set x (left-branch set))
                         (right-branch set)))
             ((> x (entry set))
              (make-tree (entry set)
                         (left-branch set)
                         (adjoin-set x (right-branch set))))))
     (define (ex2.63)
       (define (tree->list-1 tree)
         (if (null? tree)
             '()
             (append (tree->list-1 (left-branch tree))
                     (cons (entry tree)
                           (tree->list-1 (right-branch tree))))))
       (define (tree->list-2 tree)
         (define (copy-to-list tree result-list)
           (if (null? tree)
               result-list
               (copy-to-list (left-branch tree)
                             (cons (entry tree)
                                   (copy-to-list (right-branch tree)
                                                 result-list)))))
         (copy-to-list tree '()))
       (define tree '(5 (1 () (3 () ())) (6 (2 () (4 () ())) (7 () (8 () (9 () (10 () ())))))))
       (println tree)
       (println (tree->list-1 tree))
       (println (tree->list-2 tree))
       ;;; a 结果一样
       ;;; b 方法2增长慢一些, 方法1中的append操作耗费了额外的步数
       )
     (link 'ex2.63 ex2.63)

     (define (ex2.64)
       (define (list->tree elements)
         (car (partial-tree elements (length elements))))
       (define (partial-tree elts n)
         (if (= n 0)
             (cons '() elts)
             (let ((left-size (quotient (- n 1) 2)))
               (let ((left-result (partial-tree elts left-size)))
                 (let ((left-tree (car left-result))
                       (non-left-elts (cdr left-result))
                       (right-size (- n (+ left-size 1))))
                   (let ((this-entry (car non-left-elts))
                         (right-result (partial-tree (cdr non-left-elts)
                                                     right-size)))
                     (let ((right-tree (car right-result))
                           (remaining-elts (cdr right-result)))
                       (cons (make-tree this-entry left-tree right-tree)
                             remaining-elts))))))))
       (println (list->tree '(1 2 3 4 5 6 7 8 9)))
       ;;; a 取一半建立树
       )
     (link 'ex2.64 ex2.64)

     (define (tree->list tree)
       (if (null? tree)
           '()
           (append (tree->list (left-branch tree))
                   (cons (entry tree)
                         (tree->list (right-branch tree))))))
     (define (list->tree elements)
       (car (partial-tree elements (length elements))))
     (define (partial-tree elts n)
       (if (= n 0)
           (cons '() elts)
           (let ((left-size (quotient (- n 1) 2)))
             (let ((left-result (partial-tree elts left-size)))
               (let ((left-tree (car left-result))
                     (non-left-elts (cdr left-result))
                     (right-size (- n (+ left-size 1))))
                 (let ((this-entry (car non-left-elts))
                       (right-result (partial-tree (cdr non-left-elts)
                                                   right-size)))
                   (let ((right-tree (car right-result))
                         (remaining-elts (cdr right-result)))
                     (cons (make-tree this-entry left-tree right-tree)
                           remaining-elts))))))))
     
     (define (ex2.65)
       
       (define (union-list l1 l2)
         (cond ((null? l1) l2)
               ((null? l2) l1)
               (else (let ((v1 (car l1))
                           (v2 (car l2)))
                       (cond ((= v1 v2) (cons v1 (union-list (cdr l1) (cdr l2))))
                             ((< v1 v2) (cons v1 (union-list (cdr l1) l2)))
                             ((< v2 v1) (cons v2 (union-list l1 (cdr l2)))))))))
       (define (intersection-list l1 l2)
         (cond ((or (null? l1) (null? l2)) '())
               (else (let ((v1 (car l1))
                           (v2 (car l2)))
                       (cond ((= v1 v2)
                              (cons v1 (intersection-list (cdr l1) (cdr l2))))
                             ((< v1 v2)
                              (intersection-list (cdr l1) l2))
                             ((< v2 v1)
                              (intersection-list l1 (cdr l2))))))))
       (println (intersection-list '(1 2 3 4) '(3 4 5 6)))
       (define (union-set t1 t2)
         (list->tree (union-list (tree->list t1)
                                 (tree->list t2))))
       (define (intersection-set t1 t2)
         (list->tree (intersection-list (tree->list t1)
                                        (tree->list t2))))
       
       (println (list->tree '(1 3 5 7 9)))
       (println (list->tree '(2 4 6 8 10)))
       (define t (union-set (list->tree '(1 3 5 7 9))
                            (list->tree '(2 4 6 8 10))))
       (define t1 (list->tree '(1 2 3 4 5)))
       (define t2 (list->tree '(3 4 5 6 7)))
       (println t1)
       (println t2)
       (println (intersection-set t1 t2))
       )
     (link 'ex2.65 ex2.65)

     (define (ex2.66)
       (define (key elem) elem)
       (define (lookup given-key set-of-records)
         (cond ((null? set-of-records) false)
               ((equal? given-key (key (entry set-of-records)))
                (entry set-of-records))
               ((< given-key (key (entry set-of-records)))
                (lookup given-key (left-branch set-of-records)))
               (else
                (lookup given-key (left-branch set-of-records)))))
       (lookup 3 (list->tree '(1 2 3 4 5)))
       )
     (link 'ex2.66 ex2.66)
     )
   (link 'sets-as-binary-tree sets-as-binary-tree)
   (define (generating-huffman-trees)
     (define (make-leaf symbol weight) (list 'leaf symbol weight))
     (define (leaf? object) (eq? (car object) 'leaf))
     (define (symbol-leaf x) (cadr x))
     (define (weight-leaf x) (caddr x))
     (define (make-code-tree left right)
       (list left
             right
             (append (symbols left) (symbols right))
             (+ (weight left) (weight right))))
     (define (left-branch tree) (car tree))
     (define (right-branch tree) (cadr tree))
     (define (symbols tree)
       (if (leaf? tree)
           (list (symbol-leaf tree))
           (caddr tree)))
     (define (weight tree)
       (if (leaf? tree)
           (weight-leaf tree)
           (cadddr tree)))
     (define (decode bits tree)
       (define (decode-1 bits current-branch)
         (if (null? bits)
             '()
             (let ((next-branch
                    (choose-branch (car bits) current-branch)))
               (if (leaf? next-branch)
                   (cons (symbol-leaf next-branch)
                         (decode-1 (cdr bits) tree))
                   (decode-1 (cdr bits) next-branch)))))
       (decode-1 bits tree))
     (define (choose-branch bit branch)
       (cond ((= bit 0) (left-branch branch))
             ((= bit 1) (right-branch branch))
             (else (error "bad bit -- CHOOSE-BRANCH" bit))))
     (define (adjoin-set x set)
       (cond ((null? set) (list x))
             ((< (weight x) (weight (car set))) (cons x set))
             (else (cons (car set)
                         (adjoin-set x (cdr set))))))
     (define (make-leaf-set pairs)
       (if (null? pairs)
           '()
           (let ((pair (car pairs)))
             (adjoin-set (make-leaf (car pair)
                                    (cadr pair))
                         (make-leaf-set (cdr pairs))))))
     (define sample-tree
       (make-code-tree (make-leaf 'A 4)
                       (make-code-tree
                        (make-leaf 'B 2)
                        (make-code-tree (make-leaf 'D 1)
                                        (make-leaf 'C 1)))))
     (define (ex2.67)
       (define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
       (println (decode sample-message sample-tree))
       (println sample-tree)
       (println (symbol-leaf sample-tree))
       )
     (link 'ex2.67 ex2.67)

     (define (encode message tree)
       (if (null? message)
           '()
           (append (encode-symbol (car message) tree)
                   (encode (cdr message) tree))))
     (define (encode-symbol symbol tree)
       (cond ((eq? symbol (symbol-leaf tree)) '())
             ((element-of-set? symbol (symbols (left-branch tree)))
              (cons 0 (encode-symbol symbol (left-branch tree))))
             ((element-of-set? symbol (symbols (right-branch tree)))
              (cons 1 (encode-symbol symbol (right-branch tree))))
             (else (begin
                     (println symbol)
                     (error "bat symbol -- ENCODE-SYMBOL")))))
     (define (ex2.68)
       (println (encode '(A D A B B C A) sample-tree))
       )
     (link 'ex2.68 ex2.68)
     (println (make-leaf-set '(('A 4) ('B 2) ('C 1) ('D 1))))
     (println (make-code-tree (make-code-tree '(leaf 'D 1) '(leaf 'C 1))
                              '(leaf 'A 4)))
     (define (generate-huffman-tree pairs)
       (successive-merge (make-leaf-set pairs)))
     (define (successive-merge tree)
       (if (null? (cdr tree))
           (car tree)
           (successive-merge (adjoin-set (make-code-tree (car tree)
                                                         (cadr tree))
                                         (cddr tree)))))
     (define (ex2.69)
       (println (generate-huffman-tree '(('A 4) ('B 2) ('C 1) ('D 1))))
       )
     (link 'ex2.69 ex2.69)
     (define (ex2.70)
       (define tree (generate-huffman-tree '(
                                             (A 2)
                                             (NA 16)
                                             (BOOM 1)
                                             (SHA 3)
                                             (GET 2)
                                             (YIP 9)
                                             (JOB 2)
                                             (WAH 1))))
       ;;; 需要84个二进制位
       (println (length (encode '(GET A JOB) tree)))
       (println (length (encode '(SHA NA NA NA NA NA NA NA NA) tree)))
       (println (length (encode '(GET A JOB) tree)))
       (println (length (encode '(SHA NA NA NA NA NA NA NA NA) tree)))
       (println (length (encode '(WAH YIP YIP YIP YIP YIP YIP YIP YIP YIP) tree)))
       (println (length (encode '(SHA BOOM) tree)))
       ;;; 采用定长编码需要93个二进制位
       )
     (link 'ex2.70 ex2.70)

     (define (ex2.71)
       ;;; 最频繁出现的1个二进制位
       ;;; 最不频繁的n个二进制位
       (define tree (generate-huffman-tree '(
                                             (A 1)
                                             (B 2)
                                             (C 4)
                                             (D 8)
                                             (E 16)
                                             (F 32)
                                             (G 64))))
       (println tree)
       (println (encode-symbol 'A tree))
       (println (encode-symbol 'B tree))
       (println (encode-symbol 'C tree))
       (println (encode-symbol 'D tree))
       (println (encode-symbol 'E tree))
       (println (encode-symbol 'F tree))
       (println (encode-symbol 'G tree))
       )
     (link 'ex2.71 ex2.71)

     (define (ex2.72)
       ;;;
       '()
       )
     (link 'ex2.72 ex2.72)
     )
   (link 'generating-huffman-trees generating-huffman-trees)
   ))
   (last-exercise)
