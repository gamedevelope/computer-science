#lang racket

(require "common.rkt")

(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))
(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))
(define (equal-rat? x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))
(define (make-rat n d)
  (cons n d))
(define (numer x) (car x))
(define (denom x) (cdr x))

(define (ex2.1)
  (define (make-rat n d)
    (let ((g (gcd n d))
          (p (* n d)))
      (let ((q (/ p (square g)))
            (m (abs (/ d g))))
        (cons (/ q m) m))))
  (println (make-rat 1 -2))
  (println (make-rat 2 -2))
  (println (make-rat 2 -4))
  (println (make-rat -2 -4))
  (println (make-rat 0 -4))
  )
(link 'ex2.1 ex2.1)

(define (ex2.2&ex2.3)
  (define (make-segment p1 p2)
    (cons p1 p2))
  (define (start-segment s)
    (car s))
  (define (end-segment s)
    (cdr s))
  (define (make-point x y)
    (cons x y))
  (define (x-point p)
    (car p))
  (define (y-point p)
    (cdr p))
  (define (midpoint-segment s)
    (let ((p1 (start-segment s))
          (p2 (end-segment s)))
      (make-point (/ (+ (x-point p1) (x-point p2)) 2)
                  (/ (+ (y-point p1) (y-point p2)) 2))))
  (define (print-point p)
    (newline)
    (display "(")
    (display (x-point p))
    (display ",")
    (display (y-point p))
    (display ")"))
  (define (print-segment s)
    (display "[")
    (print-point (start-segment s))
    (display ",")
    (print-point (end-segment s))
    (display "]"))
  (define s (make-segment (make-point 1 2)
                          (make-point 3 4)))
  (print-segment s)
  (print-point (midpoint-segment s))

  (define (make-rectangle width height)
    (cons width height))
  (define (rectangle-weight r)
    (car r))
  (define (rectangle-height r)
    (cdr r))
  (define (rectangle-area r)
    (* (rectangle-weight r)
       (rectangle-height r)))
  (define (rectangle-circumference r)
    (* 2 (+ (rectangle-weight r)
            (rectangle-height r))))
  (newline)
  (define r1 (make-rectangle 10 20))
  (println "rectangle area and circumference")
  (println (rectangle-area r1))
  (println (rectangle-circumference r1))
  )
(link 'ex2.2&ex2.3 ex2.2&ex2.3)

(define (ex2.4)
  (define (cons x y)
    (lambda (m) (m x y)))
  (define (car z)
    (z (lambda (p q) p)))
  (define (cdr z)
    (z (lambda (p q) q)))
  (println (cdr (cdr (cons 1 (cons 2 3)))))
  (println (cons 1 '()))
  )
(link 'ex2.4 ex2.4)

(define (ex2.5)
  (define (cons a b)
    (* (expt 2 a)
       (expt 3 b)))
  (define (car x)
    (if (= 0 (remainder x 2))
        (inc (car (/ x 2)))
        0))
  (define (cdr x)
    (if (= 0 (remainder x 3))
        (inc (car (/ x 3)))
        0))
  (define r (cons 2 3))
  (println r)
  (println (car r))
  (println (cdr r))
  )
(link 'ex2.5 ex2.5)

(define (ex2.6)
  (define zero (lambda (f) (lambda (x) x)))
  (define one (lambda (f) (lambda (x) (f x))))
  (define two (lambda (f) (lambda (x) (f (f x)))))
  
  (println ((zero square) 10))
  (println ((one square) 10))
  (println ((two square) 10))
  (define (+ a b)
    (lambda (f)
      (lambda (x)
        ((a f) ((b f) x)))))
  (define (* a b)
    (lambda (f)
      (lambda (x)
        ((a (b f)) x))))
  (define three (+ one two))
  (println (((+ one one) square) 10))
  (println (((* one one) inc) 1))
  (println (((+ two (+ one two)) inc) 1))
  (println (((* two (+ one two)) inc) 1))
  (println (((* three three) inc) 1))
  (println (((+ three three) inc) 1))
  (define (add-1 n)
    (lambda (f) (lambda (x) (f ((n f) x)))))
  (println zero)
  )
(link 'ex2.6 ex2.6)

((lambda ()
   (define (add-interval x y)
     (make-interval (+ (lower-bound x) (lower-bound y))
                    (+ (upper-bound x) (upper-bound y))))
   (define (mul-interval x y)
     (let ((p1 (* (lower-bound x) (lower-bound y)))
           (p2 (* (lower-bound x) (upper-bound y)))
           (p3 (* (upper-bound x) (lower-bound y)))
           (p4 (* (upper-bound x) (upper-bound y))))
       (make-interval (min p1 p2 p3 p4)
                      (max p1 p2 p3 p4))))
   (define (div-interval x y)
     (mul-interval x
                   (make-interval (/ 1.0 (upper-bound y))
                                  (/ 1.0 (lower-bound y)))))

   ;;; ex2.7
   (define (make-interval a b) (cons a b))
   (define (lower-bound p) (car p))
   (define (upper-bound p) (cdr p))
   
   (define (ex2.7)
     (define p1 (make-interval 1 2))
     (define p2 (make-interval 3 4))
     (println (add-interval p1 p2)))
   (link 'ex2.7 ex2.7)

   (define (sub-interval x y)
     (make-interval (- (lower-bound x) (upper-bound y))
                    (- (upper-bound x) (lower-bound y))))

   ;;; ex2.8
   (define (ex2.8)
     (define p1 (make-interval 1 2))
     (define p2 (make-interval 3 4))
     (println (sub-interval p1 p2))
     )
   (link 'ex2.8 ex2.8)

   ;;; ex2.9
   (define (ex2.9)
     ;;; 用中间值与区间宽度表示的区间
     (define (make-interval-v2 a b)
       (cons a b))
     (define (lower-bound p) (- (car p) (cdr p)))
     (define (upper-bound p) (+ (car p) (cdr p)))

     (define p1 (make-interval-v2 1 2))
     (define p2 (make-interval-v2 3 4))
     (println (sub-interval p1 p2))
     )
   (link 'ex2.9 ex2.9)

   (define (ex2.10)
     (define (div-interval x y)
       (let ((uy (upper-bound y))
             (ly (lower-bound y)))
         (if (and (< ly 0)
                  (> uy 0))
             (error "Invalid arguments -- div-interval")
             (mul-interval x
                           (make-interval (/ 1.0 uy)
                                          (/ 1.0 ly))))))
     (println (div-interval (make-interval 1 2)
                            (make-interval 2 3)))
     (println (div-interval (make-interval 1 2)
                            (make-interval -2 3)))
     )
   (link 'ex2.10 ex2.10)

   (define (ex2.11)
     ;;; 根据区间端点正负关系分成9种情况讨论
     (define (mul-interval x y)
       (let ((lx (lower-bound x))
             (ux (upper-bound x))
             (ly (lower-bound y))
             (uy (upper-bound y)))
         (cond ((< 0 lx)
                (cond ((< 0 ly) (make-interval (* lx ly) (* ux uy)))
                      ((< uy 0) (make-interval (* ux ly) (* lx uy)))
                      (else (make-interval (* ux ly) (* ux uy)))))
               ((< ux 0)
                (cond ((< 0 ly) (make-interval (* lx uy) (* ux ly)))
                      ((< uy 0) (make-interval (* ux uy) (* lx ly)))
                      (else (make-interval (* lx uy) (* lx ly)))))
               (else
                (cond ((< 0 ly) (make-interval (* lx uy) (ux uy)))
                      ((< uy 0) (make-interval (* ux ly) (* lx ly)))
                      (else (make-interval (min (* lx uy) (* ux ly))
                                           (max (* lx ly) (* ux uy)))))))))
     (define x (make-interval -100 -1))
     (define y (make-interval -100 -1))
     (println (mul-interval y x))
     (println (mul-interval x y))
     )
   (link 'ex2.11 ex2.11)
   ))

(last-exercise)