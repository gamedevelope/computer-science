#lang racket

(require "common.rkt")
(require racket/trace)

(define (add-rat x y)
  (make-rat (+ (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (sub-rat x y)
  (make-rat (- (* (numer x) (denom y))
               (* (numer y) (denom x)))
            (* (denom x) (denom y))))
(define (mul-rat x y)
  (make-rat (* (numer x) (numer y))
            (* (denom x) (denom y))))
(define (div-rat x y)
  (make-rat (* (numer x) (denom y))
            (* (denom x) (numer y))))
(define (equal-rat? x y)
  (= (* (numer x) (denom y))
     (* (numer y) (denom x))))
(define (make-rat n d)
  (cons n d))
(define (numer x) (car x))
(define (denom x) (cdr x))

(define (ex2.1)
  (define (make-rat n d)
    (let ((g (gcd n d))
          (p (* n d)))
      (let ((q (/ p (square g)))
            (m (abs (/ d g))))
        (cons (/ q m) m))))
  (println (make-rat 1 -2))
  (println (make-rat 2 -2))
  (println (make-rat 2 -4))
  (println (make-rat -2 -4))
  (println (make-rat 0 -4))
  )
(link 'ex2.1 ex2.1)

(define (ex2.2&ex2.3)
  (define (make-segment p1 p2)
    (cons p1 p2))
  (define (start-segment s)
    (car s))
  (define (end-segment s)
    (cdr s))
  (define (make-point x y)
    (cons x y))
  (define (x-point p)
    (car p))
  (define (y-point p)
    (cdr p))
  (define (midpoint-segment s)
    (let ((p1 (start-segment s))
          (p2 (end-segment s)))
      (make-point (/ (+ (x-point p1) (x-point p2)) 2)
                  (/ (+ (y-point p1) (y-point p2)) 2))))
  (define (print-point p)
    (newline)
    (display "(")
    (display (x-point p))
    (display ",")
    (display (y-point p))
    (display ")"))
  (define (print-segment s)
    (display "[")
    (print-point (start-segment s))
    (display ",")
    (print-point (end-segment s))
    (display "]"))
  (define s (make-segment (make-point 1 2)
                          (make-point 3 4)))
  (print-segment s)
  (print-point (midpoint-segment s))

  (define (make-rectangle width height)
    (cons width height))
  (define (rectangle-weight r)
    (car r))
  (define (rectangle-height r)
    (cdr r))
  (define (rectangle-area r)
    (* (rectangle-weight r)
       (rectangle-height r)))
  (define (rectangle-circumference r)
    (* 2 (+ (rectangle-weight r)
            (rectangle-height r))))
  (newline)
  (define r1 (make-rectangle 10 20))
  (println "rectangle area and circumference")
  (println (rectangle-area r1))
  (println (rectangle-circumference r1))
  )
(link 'ex2.2&ex2.3 ex2.2&ex2.3)

(define (ex2.4)
  (define (cons x y)
    (lambda (m) (m x y)))
  (define (car z)
    (z (lambda (p q) p)))
  (define (cdr z)
    (z (lambda (p q) q)))
  (println (cdr (cdr (cons 1 (cons 2 3)))))
  (println (cons 1 '()))
  )
(link 'ex2.4 ex2.4)

(define (ex2.5)
  (define (cons a b)
    (* (expt 2 a)
       (expt 3 b)))
  (define (car x)
    (if (= 0 (remainder x 2))
        (inc (car (/ x 2)))
        0))
  (define (cdr x)
    (if (= 0 (remainder x 3))
        (inc (car (/ x 3)))
        0))
  (define r (cons 2 3))
  (println r)
  (println (car r))
  (println (cdr r))
  )
(link 'ex2.5 ex2.5)

(define (ex2.6)
  (define zero (lambda (f) (lambda (x) x)))
  (define one (lambda (f) (lambda (x) (f x))))
  (define two (lambda (f) (lambda (x) (f (f x)))))
  
  (println ((zero square) 10))
  (println ((one square) 10))
  (println ((two square) 10))
  (define (+ a b)
    (lambda (f)
      (lambda (x)
        ((a f) ((b f) x)))))
  (define (* a b)
    (lambda (f)
      (lambda (x)
        ((a (b f)) x))))
  (define three (+ one two))
  (println (((+ one one) square) 10))
  (println (((* one one) inc) 1))
  (println (((+ two (+ one two)) inc) 1))
  (println (((* two (+ one two)) inc) 1))
  (println (((* three three) inc) 1))
  (println (((+ three three) inc) 1))
  (define (add-1 n)
    (lambda (f) (lambda (x) (f ((n f) x)))))
  (println zero)
  )
(link 'ex2.6 ex2.6)

((lambda ()
   (define (add-interval x y)
     (make-interval (+ (lower-bound x) (lower-bound y))
                    (+ (upper-bound x) (upper-bound y))))
   (define (mul-interval x y)
     (let ((p1 (* (lower-bound x) (lower-bound y)))
           (p2 (* (lower-bound x) (upper-bound y)))
           (p3 (* (upper-bound x) (lower-bound y)))
           (p4 (* (upper-bound x) (upper-bound y))))
       (make-interval (min p1 p2 p3 p4)
                      (max p1 p2 p3 p4))))
   (define (div-interval x y)
     (mul-interval x
                   (make-interval (/ 1.0 (upper-bound y))
                                  (/ 1.0 (lower-bound y)))))

   ;;; ex2.7
   (define (make-interval a b) (cons a b))
   (define (lower-bound p) (car p))
   (define (upper-bound p) (cdr p))
   
   (define (ex2.7)
     (define p1 (make-interval 1 2))
     (define p2 (make-interval 3 4))
     (println (add-interval p1 p2)))
   (link 'ex2.7 ex2.7)

   (define (sub-interval x y)
     (make-interval (- (lower-bound x) (upper-bound y))
                    (- (upper-bound x) (lower-bound y))))

   ;;; ex2.8
   (define (ex2.8)
     (define p1 (make-interval 1 2))
     (define p2 (make-interval 3 4))
     (println (sub-interval p1 p2))
     )
   (link 'ex2.8 ex2.8)

   ;;; ex2.9
   (define (ex2.9)
     ;;; 用中间值与区间宽度表示的区间
     (define (make-interval-v2 a b)
       (cons a b))
     (define (lower-bound p) (- (car p) (cdr p)))
     (define (upper-bound p) (+ (car p) (cdr p)))

     (define p1 (make-interval-v2 1 2))
     (define p2 (make-interval-v2 3 4))
     (println (sub-interval p1 p2))
     )
   (link 'ex2.9 ex2.9)

   (define (ex2.10)
     (define (div-interval x y)
       (let ((uy (upper-bound y))
             (ly (lower-bound y)))
         (if (and (< ly 0)
                  (> uy 0))
             (error "Invalid arguments -- div-interval")
             (mul-interval x
                           (make-interval (/ 1.0 uy)
                                          (/ 1.0 ly))))))
     (println (div-interval (make-interval 1 2)
                            (make-interval 2 3)))
     (println (div-interval (make-interval 1 2)
                            (make-interval -2 3)))
     )
   (link 'ex2.10 ex2.10)

   (define (ex2.11)
     ;;; 根据区间端点正负关系分成9种情况讨论
     (define (mul-interval x y)
       (let ((lx (lower-bound x))
             (ux (upper-bound x))
             (ly (lower-bound y))
             (uy (upper-bound y)))
         (cond ((< 0 lx)
                (cond ((< 0 ly) (make-interval (* lx ly) (* ux uy)))
                      ((< uy 0) (make-interval (* ux ly) (* lx uy)))
                      (else (make-interval (* ux ly) (* ux uy)))))
               ((< ux 0)
                (cond ((< 0 ly) (make-interval (* lx uy) (* ux ly)))
                      ((< uy 0) (make-interval (* ux uy) (* lx ly)))
                      (else (make-interval (* lx uy) (* lx ly)))))
               (else
                (cond ((< 0 ly) (make-interval (* lx uy) (ux uy)))
                      ((< uy 0) (make-interval (* ux ly) (* lx ly)))
                      (else (make-interval (min (* lx uy) (* ux ly))
                                           (max (* lx ly) (* ux uy)))))))))
     (define x (make-interval -100 -1))
     (define y (make-interval -100 -1))
     (println (mul-interval y x))
     (println (mul-interval x y))
     )
   (link 'ex2.11 ex2.11)

   (define (ex2.12&2.13)
     (define (make-center-width c w)
       (make-interval (- c w) (+ c w)))
     (define (center i)
       (/ (+ (lower-bound i) (upper-bound i)) 2))
     (define (width i)
       (/ (- (upper-bound i) (lower-bound i)) 2))
     
     (define (make-center-percent c p)
       (make-center-width c (* c (/ p 100.0))))
     (define (percent i)
       (* 100.0 (/ (- (upper-bound i) (lower-bound i))
                   (+ (upper-bound i) (lower-bound i)))))

     (define i1 (make-center-percent 100 1))
     (println i1)

     ;;; ex2.13 当误差很小时，两个区间乘积的误差约等于两个区间的误差之和
     (define i2 (make-center-percent 100 10))
     (println i2)

     (define i3 (make-center-percent 100 10))
     (println i3)
     
     (println (percent i2))
     (println (percent i3))
     (define i4 (mul-interval i2 i3))
     (println i4)
     (println (percent i4))
     )
   (link 'ex2.12&2.13 ex2.12&2.13)

   ;;; 这道题让我对初中的电阻计算公式认识更深了
   ;;; 误差范围较小时，两个公式计算结果接近
   (define (ex2.14)
     (define (par1 r1 r2)
       (div-interval (mul-interval r1 r2)
                     (add-interval r1 r2)))
     (define (par2 r1 r2)
       (let ((one (make-interval 1 1)))
         (div-interval one
                       (add-interval (div-interval one r1)
                                     (div-interval one r2)))))

     (define r1 (make-interval 10 20))
     (define r2 (make-interval 5 10))
     (println (par1 r1 r2))
     (println (par2 r1 r2))
     )
   (link 'ex2.14 ex2.14)

   (define (ex2.17)
     (define (last-pair list)
       (if (null? (cdr list))
           (cons (car list) '())
           (last-pair (cdr list))))
     (println (last-pair (list 23 72 149 34)))
     (println (last-pair '()))
     )
   (link 'ex2.17 ex2.17)

   (define (ex2.18)
     (define (reverse list)
       (if (null? list) '()
           (append (reverse (cdr list))
                   (cons (car list) '()))))
     (println (reverse '(1 2 3 4 5)))
     )
   (link 'ex2.18 ex2.18)

   (define (ex2.19)
     (define (count-change amount) (cc amount 5))
     (define (cc amount kinds-of-coins)
       (cond ((= amount 0) 1)
             ((or (< amount 0) (= kinds-of-coins 0)) 0)
             (else (+ (cc amount
                          (- kinds-of-coins 1))
                      (cc (- amount
                             (first-denomination
                              kinds-of-coins))
                          kinds-of-coins)))))
     (define (first-denomination kinds-of-coins)
       (cond ((= kinds-of-coins 1) 1)
             ((= kinds-of-coins 2) 5)
             ((= kinds-of-coins 3) 10)
             ((= kinds-of-coins 4) 25)
             ((= kinds-of-coins 5) 50))
       )
     (println (count-change 100))
     
     (define us-coins (list 50 25 10 5 1))
     (define uk-coins (list 100 50 20 10 5 2 1 0.5))

     (define (cc-v2 amount coin-values)
       (cond ((= amount 0) 1)
             ((or (< amount 0) (no-more? coin-values)) 0)
             (else
              (+ (cc-v2 amount
                        (except-first-denomination coin-values))
                 (cc-v2 (- amount
                           (first-denomination-v2 coin-values))
                        coin-values)))))
     (define no-more? null?)
     (define (first-denomination-v2 coin-values)
       (car coin-values))
     (define (except-first-denomination coin-values)
       (cdr coin-values))
     
     (println (cc-v2 100 us-coins))
     (println (cc-v2 10 uk-coins))
     )
   (link 'ex2.19 ex2.19)
   
   (define (ex2.20)
     ((λ ()
       (define (same-parity u . lst)
         (cond [(null? lst) (list u)]
               [(eq? (odd? u) (odd? (car lst)))
                (cons u (apply same-parity lst))]
               [else
                (apply same-parity u (cdr lst))]))
        (println (same-parity 1))
        (println (same-parity 1 1 1 1 1 1))
        (println (same-parity 1 2 3 4 5))
        (println (same-parity 2 3 4 5 6))
       ))

     ((λ ()
        (define (same-parity u . list)
          (cons u (filter (if (odd? u) odd? even?) list)))
        (println (same-parity 1))
        (println (same-parity 1 1 1 1 1 1))
        (println (same-parity 1 2 3 4 5))
        (println (same-parity 2 3 4 5 6))
        ))
     )
   (link 'ex2.20 ex2.20)

   (define (ex2.21)
     ((λ ()
        (define (square-list items)
          (if (null? items) '()
              (cons (square (car items))
                    (square-list (cdr items)))))
        (println (square-list '(1 2 3 4)))
        ))
     ((λ ()
        (define (square-list items)
          (map square items))
        (println (square-list '(1 2 3 4)))
        ))
     )
   (link 'ex2.21 ex2.21)

   (define (ex2.22)
     ;;; 错误的迭代版本1
     ((λ ()
        (define (square-list items)
          (define (iter things answer)
            (if (null? things) answer
                (iter (cdr things)
                      (cons (square (car things))
                            answer))))
          (iter items '()))
        (println (square-list '(1 2 3 4)))))
     ;;; 错误的迭代版本2
     ((λ ()
        (define (square-list items)
          (define (iter things answer)
            (if (null? things) answer
                (iter (cdr things)
                      (cons answer (square (car things))))))
          (iter items '()))
        (println (square-list '(1 2 3 4)))
        ))
     ;;; 正确实现迭代版本
     ((λ ()
        (define (square-list items)
          (define (iter things answer)
            (if (null? things) answer
                (iter (cdr things)
                      (append answer (list (square (car things)))))))
          (iter items '()))
        (println (square-list '(1 2 3 4)))
        ))
     )
   (link 'ex2.22 ex2.22)

   (define (ex2.23)
     (define (for-each f items)
       (if (null? items) (void)
           (begin
             (f (car items))
             (for-each f (cdr items)))))
     (for-each display '(1 2 3 4 5))
     )
   (link 'ex2.23 ex2.23)

   (define (count-leaves x)
     (cond ((null? x) 0)
           ((not (pair? x)) 1)
           (else
            (+ (count-leaves (car x))
               (count-leaves (cdr x))))))
   (define x (cons (list 1 2) (list 3 4)))
   (println (count-leaves (list x x)))
   (println (count-leaves (cons (list 1 2) (list 3 4))))

   (define (ex2.25)
     (println (car (cdr (car (cdr (cdr '(1 2 (5 7) 9)))))))
     (println (car (car '((7)))))
     (println (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr (car (cdr '(1 (2 (3 (4 (5 (6 7)))))))))))))))))))
     )
   (link 'ex2.25 ex2.25)

   (define (ex2.26)
     (define x (list 1 2 3))
     (define y (list 4 5 6))
     (println (append x y))
     (println (cons x y))
     (println (list x y)))
   (link 'ex2.26 ex2.26)

   (define (ex2.27)
     (define (deep-reverse lst)
       (cond ((null? lst) '())
             ((not (pair? lst)) lst)
             (else (append (deep-reverse (cdr lst))
                           (list (deep-reverse (car lst)))))))
     (println (deep-reverse '(1 2 3 4)))
     (println (deep-reverse '((1 2) (3 4))))
     (println (deep-reverse '((1 2) (3 4) 5 6)))
     )
   (link 'ex2.27 ex2.27)
   ))

(last-exercise)